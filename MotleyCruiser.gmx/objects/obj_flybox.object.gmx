<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init
drawgui = true;

/***
These can be overwritten. They will be reapplied and calculated in the parsing state. See Step event.
***/
text = "";
font = fnt_messagebox;
boxw = room_width;// or view_width or gui_width
boxh = 200;
boxx1 = x;// Start x position. upper left
boxy1 = y;// Start y position. upper left
pad_l = 16;
pad_r=16;
pad_t=16;
pad_b=16;
drawbox = true;
yoffset_max = room_height - boxy1;/// Max offset from bottom
popspeed = 1000;// speed the window moves at.
spd = 3;
desty=noone;// If moving the box up, this is the final y position
portrait = noone;// A sprite
options=noone;
option_target=noone;// The object to send the answer to. It should contain conditional statements that refer to the selected option and an array called fly_conditionals.
option_index=noone;// The index of the question currently being asked. The option_target object should have an array called fly_conditionals.




// These dependant variables will be updated in the parsing step according to the base settings above
boxx2 = boxx1 + boxw;
boxy2 = boxy1 + boxh;
maxlength = boxw - pad_l - pad_r;
maxheight = boxh - pad_t - pad_b;
text_length = string_length(text);
font_size = font_get_size(font);
draw_set_font(font);
text_width = string_width_ext(text,font_size+(font_size/2),maxlength);
text_height = string_height_ext(text,font_size+(font_size/2),maxlength);
maxlines=0;
yoffset = 0;// decrease yoffset when moving


// State variables. Leave as-is.
state = "init";//init,parsing,moving,printing,displaying_options,waiting_for_option,option_selected,sending_option
time = 0;// increment this by print speed setting
depth = -100000;
destroy=false;
words=noone;// An array of words to be fed to the typewriter script


// portrait tracking - do not overwrite
pwidth = 0;
pheight = 0;

// options tracking - do not overwrite
options_triggered=false;// Ready to show options
showoptions=false;
option_selected = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy on timer
destroy = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States
if(destroy){
    if(instance_exists(obj_flyoption)){
        with(obj_flyoption){
            destroy=true;
        }
    }
    instance_destroy();
}
if(state=="init")
{
    // Do nothing. Waiting for go.
}
else if(state="parsing")
{
    if(portrait){
        pwidth = round(boxw/6);
        pheight = pwidth;        
        pad_l = pad_l + pwidth;
    }
    

    boxx2 = boxx1 + boxw;
    boxy2 = boxy1 + boxh;
    maxlength = boxw - pad_l - pad_r;
    maxheight = boxh - pad_t - pad_b;
    text_length = string_length(text);
    font_size = font_get_size(font);
    draw_set_font(font);
    text_width = string_width_ext(text,font_size+(font_size/2),maxlength);
    text_height = string_height_ext(text,font_size+(font_size/2),maxlength);

    maxlines = round(maxheight/(font_size + font_size/2)); 
    words = scr_stringtowords(text);
    
    if(desty!=noone){
        state="moving";
    }else{
        state="printing";
    }
    
    
}
else if(state == "moving")
{

    // yoffset is used to calculate y coordinate in the Draw event.
    if(desty!=noone){
        var ydist = yoffset_max - yoffset;
        var mv = popspeed/room_speed;
        if( yoffset &lt;= mv ){
            yoffset = 0;
            state="printing";
        }else{
            yoffset -= mv;
        }       
        
    }else{
        state="printing";
    }
    

}
else if(state == "displaying_options")
{
    state="waiting_for_option";
    if(instance_exists(obj_flyoption)){
        with(obj_flyoption){
            destroy=true;
        }
    }
    if(options!=noone){
        var xx=boxx1+16;
        var yy=boxy2 - (sprite_get_height(spr_flyoption)/2);
        //var yy=boxy1;
        var op;
        for(var i=0;i&lt;array_length_1d(options);i++){
            op = instance_create(xx,yy,obj_flyoption);
            op.index = i+1;
            op.str = options[i];
            if(option_target==noone){
                op.option_target = self;
            }else{
                op.option_target = option_target;
            }
            op.option_index = option_index;
            op.depth=depth-10;
            xx += op.sprite_width + 8;
        }
    }
}else if(state=="waiting_for_option"){
    //

}else if(state == "option_selected")
{
    state="sending_option";
    if(instance_exists(obj_flyoption)){
        with(obj_flyoption){
            destroy=true;
        }
    }
    destroy=true;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Execute. Sets everything in motion. Call this once you have set all variables.
state="parsing";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Render textbox &amp; text
if(!drawgui) exit;

boxx1=0;
boxy1= global.gui_height - (yoffset_max - yoffset);
boxx2 = boxx1+boxw;
boxy2 = boxy1+boxh;



if(drawbox){
    draw_set_color(c_white);
    draw_rectangle(boxx1,boxy1,boxx2,boxy2,false);
    
    draw_set_color(c_dkgray);
    draw_rectangle(boxx1,boxy1+4,boxx2,boxy2-4,false);
}

if(portrait){

    draw_set_color(c_white);
    draw_rectangle(boxx1+6, boxy1+10, boxx1+pwidth+2, boxy1+pwidth+2, false);
    draw_set_color(c_black);
    draw_rectangle(boxx1+8, boxy1+12, boxx1+pwidth, boxy1+pwidth, false);

    
    swidth = sprite_get_width(portrait);
    scl = round( pwidth/swidth ) - 1;
    if(sprite_exists(portrait)){
        draw_sprite_part_ext(portrait, 0, (swidth/2)-8, 0, 16, 16, boxx1+14, boxy1+14, scl, scl, c_white, 1);
    }
}


draw_set_font(font);
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);


if(state == "printing"){
    if( time &lt; text_length ){
        time += spd;
    }else{
        state="displaying_options";
    }
}

scr_typewriter(words, boxx1 + pad_l, boxy1 + pad_t, maxlength, floor(time));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Render textbox &amp; text
if(drawgui) exit;

if(view_visible[0]){
    boxx1=view_xview[0];
    boxy1=view_yview[0] + view_hview[0] - (yoffset_max - yoffset);
    boxx2 = boxx1+boxw;
    boxy2 = boxy1+boxh;
}else{
    boxx1=0;
    boxy1=room_height - (yoffset_max - yoffset);
    boxx2 = boxx1+boxw;
    boxy2 = boxy1+boxh;
}


if(drawbox){
    draw_set_color(c_white);
    draw_rectangle(boxx1,boxy1,boxx2,boxy2,false);
    //draw_set_color(c_white);
    //draw_line(boxx1,boxy1,boxx2,boxy1);
    //draw_line(boxx1,boxy2,boxx2,boxy2);   
    //draw_line(boxx1,boxy1+3,boxx2,boxy1+3);
    //draw_line(boxx1,boxy2-3,boxx2,boxy2-3);
    
    draw_set_color(c_dkgray);
    draw_rectangle(boxx1,boxy1+4,boxx2,boxy2-4,false);
}

if(portrait){

    draw_set_color(c_white);
    draw_rectangle(boxx1+6, boxy1+10, boxx1+pwidth+2, boxy1+pwidth+2, false);
    draw_set_color(c_black);
    draw_rectangle(boxx1+8, boxy1+12, boxx1+pwidth, boxy1+pwidth, false);

    
    swidth = sprite_get_width(portrait);
    scl = round( pwidth/swidth ) - 1;
    if(sprite_exists(portrait)){
        draw_sprite_part_ext(portrait, 0, (swidth/2)-8, 0, 16, 16, boxx1+14, boxy1+14, scl, scl, c_white, 1);
    }

}


draw_set_font(font);
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);


if(state == "printing"){
    if( time &lt; text_length ){
        time += spd;
    }else{
        state="displaying_options";
    }
}

scr_typewriter(words, boxx1 + pad_l, boxy1 + pad_t, maxlength, floor(time));



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
