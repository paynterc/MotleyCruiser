<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set up grid, draw room
width = 80;
height = 46;
cellWidth = 32;
enum cell {
    void,
    ground,
    wall
}

room_width = cellWidth * width;
room_height = cellWidth * height;

global.grid = ds_grid_create(width, height);
global.grid_path = mp_grid_create(0,0,width,height,cellWidth,cellWidth);


// Fill the global.grid with cell.voids
ds_grid_set_region(global.grid, 0, 0, width-1, height-1, cell.void);


randomize();

// Create the controller in the center of the global.grid
var cx = width div 2;
var cy = height div 2;
var x1,y1,x2,y2;
var x1r, y1r, x2r, y2r;



// Make a vertical line of random length


x1 = cx;
y1 = max(2,irandom_range(2,cy-1));
x2 = cx;
y2 = min(height-2,irandom_range(cy+1,height-2));


// Repeat this X times
var V=true;// Vertical first
for(var i=0; i&lt;5; i++){

    ds_grid_set_region(global.grid, x1, y1, x2, y2, cell.ground);
    show_debug_message("HALL CREATED");
    
    
    // Draw rooms at either end.
    var rmSize = 5;
    x1r = max(2,x1-irandom(rmSize));
    y1r = max(2,y1-irandom(rmSize));
    x2r = min(width-2,x1+irandom(rmSize));
    y2r = min(height-2,y1+irandom(rmSize));
    ds_grid_set_region(global.grid, x1r, y1r, x2r, y2r, cell.ground);
    
    x1r = max(1,x1-irandom(rmSize));
    y1r = max(1,y2-irandom(rmSize));
    x2r = min(width-1,x1+irandom(rmSize));
    y2r = min(height-1,y2+irandom(rmSize));
    ds_grid_set_region(global.grid, x1r, y1r, x2r, y2r, cell.ground);
    
    V=!V;
    
    if(V){
        cx = irandom_range(x1,x2);
        x1 = cx;
        y1 = max(2,irandom_range(2,cy-1));
        x2 = cx;
        y2 = min(height-2,irandom_range(cy+1,height-2));
        
    }else{
        cy = irandom_range(y1,y2);
        x1 = max(2,irandom_range(2,cx-1));
        y1 = cy;
        x2 = min(width-2,irandom_range(cx+1,width-2));
        y2 = cy;
        
    }

}

show_debug_message("ROOM CREATED");
// Toggle horizontal and repeat



//scr_add_wall_tiles(width,height);
for(var yy = 1; yy &lt; height-1; yy++){
    for(var xx=1; xx &lt; width-1; xx++){
        if(global.grid[# xx, yy] == cell.ground){
        
            if(global.grid[# xx+1, yy] == cell.void){
                global.grid[# xx+1, yy] = cell.wall;
            }
            if(global.grid[# xx-1, yy] == cell.void){
                global.grid[# xx-1, yy] = cell.wall;
            }
            if(global.grid[# xx, yy+1] == cell.void){
                global.grid[# xx, yy+1] = cell.wall;
            }
            if(global.grid[# xx, yy-1] == cell.void){
                global.grid[# xx, yy-1] = cell.wall;
            }
            
            if(global.grid[# xx+1, yy-1] == cell.void){
                // TOP RIGHT
                global.grid[# xx+1, yy-1] = cell.wall;
            }
            if(global.grid[# xx-1, yy-1] == cell.void){
                // TOP LEFT
                global.grid[# xx-1, yy-1] = cell.wall;
            }
            if(global.grid[# xx+1, yy+1] == cell.void){
                // BOTTOM RIGHT
                global.grid[# xx+1, yy+1] = cell.wall;
            }
            if(global.grid[# xx-1, yy+1] == cell.void){
                // BOTTOM LEFT
                global.grid[# xx-1, yy+1] = cell.wall;
            }
                       
        }  
    }
}

var wall_tile = bg_wall_simple;
var floor_tile = bg_floor2;


// Add tiles and path map

for(var yy = 0; yy &lt; height; yy++){
    for(var xx = 0; xx &lt; width; xx++){
        if(global.grid[# xx, yy] == cell.ground){
            
            tile_add(floor_tile, 0, 0, cellWidth, cellWidth, xx*cellWidth, yy*cellWidth, 0);          
          
        }else{
            //This is a wall or cell.void. Add a solid cell to the pathfinding global.grid.
            mp_grid_add_cell(global.grid_path,xx,yy);
            
        }
    }
}

// WALLS
for(var yy = 0; yy &lt; height; yy++){
    for(var xx = 0; xx &lt; width; xx++){
        if(global.grid[# xx, yy] == cell.wall){
            
            
            var voidAbove = global.grid[# xx, yy-1] == cell.void;
            var voidBelow = global.grid[# xx, yy+1] == cell.void;
            var floorAbove = global.grid[# xx, yy-1] == cell.ground;
            var floorBelow = global.grid[# xx, yy+1] == cell.ground;
            
            if(voidBelow){
                tile_add(wall_tile, cellWidth,0, cellWidth, cellWidth*2, xx*cellWidth, yy*cellWidth - (cellWidth/2), -1);
            
            }else if(floorBelow){
                // Draw a room wall tile
                tile_add(wall_tile, 0,0, cellWidth, cellWidth*2, xx*cellWidth, yy*cellWidth - (cellWidth/2), -1);
                
            }else{
                // draw a ceiling tile
                tile_add(wall_tile, 0, 0, cellWidth, cellWidth, xx*cellWidth, yy*cellWidth, -1);
            }
            
            
            if(floorAbove){
                //If floor above, make sure the ceiling is high enough depth to hide the player and shadow partially as it walks by
                tile_add(wall_tile, 0, 0, cellWidth, cellWidth, xx*cellWidth, yy*cellWidth - (cellWidth/2), -100000);
            }

            if(voidAbove){

                tile_add(wall_tile, 0, 0, cellWidth, cellWidth, xx*cellWidth, yy*cellWidth - (cellWidth/2), -1);
            }
                                            
        }
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_grid_destroy(global.grid);
mp_grid_destroy(global.grid_path);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="97">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(room);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
