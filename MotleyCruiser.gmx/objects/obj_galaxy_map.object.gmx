<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init
gui_width = display_get_gui_width();
gui_height = display_get_gui_height();

view_xview[0]=0;
view_yview[0]=0;
view_wview[0] = view_wview[0] * GX_MAGNITUDE;
view_hview[0] = view_hview[0] * GX_MAGNITUDE;


// Add the "add path" button
btn_addpath = instance_create(32,gui_height-64-32,obj_btn_addpath);
with(btn_addpath){
    event_user(0);
}

// Limit the distance the view can move
vLimitTop=0;
vLimitBtm=0;
vLimitLft=0;
vLimitRgt=0;
vTSet=false;vBSet=false;vLSet=false;vRSet=false;

/****
    GX_GRIDSIZE sets the spacing of the points within the grid.
    GX_MAGNITUDE controls the size of map elements when drawn.

    shift, command, G to reach map room
    
    // offsets within each sector are set this way
    var ofsetx=irandom(GX_GRIDSIZE)-(GX_GRIDSIZE/2);
    var ofsety=irandom(GX_GRIDSIZE)-(GX_GRIDSIZE/2);
    gxMapKey = "x"+string(sx)+"y"+string(sy)+"mapoffsets";
    ds_map_add(global.galaxy, gxMapKey, string(ofsetx)+","+string(ofsety));    
****/


// default colors
clr1=c_white;
clr2=c_aqua;

// current sector colors
clr3=c_aqua;
clr4=c_white;

// Triangle points
tx1=0;
tx2=0;
tx3=0;
ty1=0;
ty2=0;
ty3=0;

event_user(1);// Update map data


// Gui Buttons
mButtons = noone;
var clrBtn = scr_gui_entity_button();
clrBtn[BTN_TXT]="CLEAR";
clrBtn[BTN_X] = 32;
clrBtn[BTN_Y] = 32;
clrBtn[BTN_W]=80;
clrBtn[BTN_H]=32;

var exitBtn = scr_gui_entity_button();
exitBtn[BTN_TXT]="EXIT";
exitBtn[BTN_W]=80;
exitBtn[BTN_H]=32;
exitBtn[BTN_X] = gui_width - exitBtn[BTN_W] - 32;
exitBtn[BTN_Y] = gui_height - exitBtn[BTN_H] - 32;

mButtons= scr_array(clrBtn,exitBtn);

event_user(0);//update selected paths
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// User input
var viewSpeed = 8;
if(scr_user_input(pin.thrust)){
    if(view_yview[0] + view_hview[0] &gt; vLimitTop){
        view_yview[0] -= viewSpeed;
    }
    
}else if(scr_user_input(pin.thrust_reverse)){
    if(view_yview[0]&lt;vLimitBtm){
        view_yview[0] += viewSpeed;
    }
}

if(scr_user_input(pin.turn_left)){
    if(view_xview[0] + view_wview[0] &gt; vLimitLft){
        view_xview[0] -= viewSpeed;
    }    
}else if(scr_user_input(pin.turn_right)){
    if(view_xview[0]&lt;vLimitRgt){
        view_xview[0] += viewSpeed;
    }
}

if(is_array(mButtons)){
    var clrBtn = mButtons[0];
    clrBtn[@BTN_SHOW] = array_length_1d(global.nav_queue)&gt;0;
    var guix = device_mouse_x_to_gui(0);
    var guiy = device_mouse_y_to_gui(0);
    for(var i = 0; i&lt;array_length_1d(mButtons); i++){
        thebutton = mButtons[i];
        if(thebutton[BTN_SHOW]){  
            xhover = ( guix == median(thebutton[BTN_X], guix, thebutton[BTN_X] + thebutton[BTN_W]) );
            yhover = ( guiy == median(thebutton[BTN_Y], guiy, thebutton[BTN_Y] + thebutton[BTN_H]) );
            thebutton[@ 4] = xhover &amp;&amp; yhover;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gui button pressed
var bIdx = noone;
for(var i=0; i&lt;array_length_1d(mButtons); i++){
    var btn=mButtons[i];
    if(btn[BTN_HOVER] &amp;&amp; btn[BTN_SHOW]){
        // BTN_SHOW will only be true if the resource is at zero
        bIdx = i;// Return  index of clicked button.
        break;
    }
}
if(bIdx==0){
    // Clear nav points
    global.nav_queue = noone;
    if(instance_exists(obj_galaxy_map)){
        with(obj_galaxy_map){
            event_user(0);
        }
    }
}else if(bIdx==1){
    // Exit map room
    room_goto(rm_space);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update map data

// Iterate over global.galaxy_map for system locations
with(obj_gxmap_point){
    instance_destroy();
}
points=noone;
paths=noone;// An array pathsSelectedof points to draw lines. array(0=&gt;[x1,y1,x2,y2],1=&gt;[x1,y1,x2,y2])
pathsSelected=noone;// An array of selected nav routes to draw lines of second color
var gxX;
var gxY;
var gxPts;
var oSets;
var size = ds_map_size(global.galaxy);
var key = ds_map_find_first(global.galaxy);
var keyArray = noone;
ctrX=0;
ctrY=0;
var pointObj;
var ptX=0;
var ptY=0;
var pathDataStore=noone;
show_debug_message("START READING MAP");
for (var i = 0; i &lt; size; i++;)
{
    keyArray= scr_push_array(keyArray,key);
    gxX=real(string_copy(key, 2, string_pos("y",key)-2 ));// Galaxy X
    gxY=real(string_copy(key, string_pos("y",key)+1, string_pos("~",key)-string_pos("y",key)-1 ));// Galaxy Y
    if( string_pos("mapoffsets",key) != 0)
    {
        show_debug_message("GX Map offsets: " + string(gxX) + ", " +string(gxY));
        oSets = scr_str_split(ds_map_find_value(global.galaxy,key),",");
        gxPts = scr_array(real(gxX),real(gxY),real(oSets[0]),real(oSets[1]));
        
        ptX = scr_gxmap_calcpoint(gxPts[0],gxPts[2]);
        ptY = scr_gxmap_calcpoint(gxPts[1],gxPts[3]);
                          
        points = scr_push_array(points,scr_array(ptX,ptY));
        
        pointObj = instance_create(ptX,ptY,obj_gxmap_point);
        pointObj.gx=gxX;
        pointObj.gy=gxY;

        
        
        // Limit view
        if(!vTSet){
            vTSet=true;
            vLimitTop = ptY;
        }
        if(!vBSet){
            vBSet=true;
            vLimitBtm = ptY;
        }
        if(!vLSet){
            vLSet=true;
            vLimitLft = ptX;
        }        
        if(!vRSet){
            vRSet=true;
            vLimitRgt = ptX;
        }
              
        if(ptX&gt;vLimitRgt){
            vLimitRgt = ptX;
        }else if(ptX &lt; vLimitLft){
            vLimitLft = ptX;           
        }
        
        if(ptY&gt;vLimitBtm){
            vLimitBtm = ptY;
        }else if(ptY &lt; vLimitTop){
            vLimitTop = ptY;           
        }
        
        // points = [gx,gy,oSetx,oSety]
        if(real(gxX)==global.sector_x &amp;&amp; real(gxY)== global.sector_y ){
            
            // This is the sector where we are currently. Center the view here
            view_xview[0]=ptX-(view_wview[0]/2);
            view_yview[0]=ptY-(view_hview[0]/2);
            
            // Update the point object with a flag
            if(pointObj!=noone){
                pointObj.is_current=true;
            }
            
            
            // Draw a special circle at this location
            ctrX=ptX;
            ctrY=ptY;
                     
            // Set up the triangle marker
            tx1=ptX;
            tx2=ptX-4*GX_MAGNITUDE;
            tx3=ptX+4*GX_MAGNITUDE;
            ty1=ptY+(8*GX_MAGNITUDE);
            ty2=ty1+(4*GX_MAGNITUDE);
            ty3=ty2;          
                 
        }
                       
    }
    
    
    if( string_pos("paths",key) != 0)
    {


        // Calculate the paths leading from this sector. [x1,y1,x2,y2,false]. The last index will be true if there is a return path
        var pathData = ds_map_find_value(global.galaxy,key);// Should be an array of sector coordinates like ["0,1","0,-1","-1,-1"]
        if(is_array(pathData)){
        
            var newPStore = scr_array(scr_array(gxX,gxY),pathData);
            pathDataStore = scr_push_array(pathDataStore,newPStore);
            
            // Get the offsets for whatever sector these paths belong to. This would be contained in the key.
            var oSetString = scr_gx_get_by_key(gxX,gxY,"mapoffsets");

            if(!is_undefined(oSetString)){
                oSets = scr_str_split(oSetString,","); 
                
                var x1= scr_gxmap_calcpoint(gxX,oSets[0]);
                var y1 = scr_gxmap_calcpoint(gxY,oSets[1]);
                
                // Now go through and get the map offsets for each sector in the path array
                var oSetString2,oSets2,pth,x2,y2;
                for(var aa=0; aa&lt;array_length_1d(pathData); aa++){
                    pth = scr_str_split(pathData[aa],",");
                    oSetString2=scr_gx_get_by_key(pth[0],pth[1],"mapoffsets");
                    if(!is_undefined(oSetString2)){
                        oSets2 = scr_str_split(oSetString2,",");           
                        x2 = scr_gxmap_calcpoint( real(pth[0]), real(oSets2[0]) );
                        y2 = scr_gxmap_calcpoint( real(pth[1]), real(oSets2[1]) );
                        
                        paths = scr_push_array(paths,scr_array(x1,y1,x2,y2,false));
                    }
                    
                }
                
            }
    
        }
       
    }
    
    key = ds_map_find_next(global.galaxy, key);

}
show_debug_message("COMPLETED READING MAP");

// Flag paths that have return paths
if(is_array(paths)){
    var pLength = array_length_1d(paths);
    var pathsCopy = noone;
    pathsCopy[0]=noone;
    array_copy(pathsCopy,0,paths,0,pLength);
    for(var i=0; i&lt;array_length_1d(paths);i++){
        var thisPath = paths[i];
        scr_gx_findsister_path(thisPath,pathsCopy);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update nav lines
var p, pA, oSetString, oSets, x1, y1;
pathsSelected = noone;

oSetString = scr_gx_get_by_key(global.sector_x,global.sector_y,"mapoffsets");
if(!is_undefined(oSetString)){
   oSets = scr_str_split(oSetString,",");
   x1 = scr_gxmap_calcpoint(global.sector_x,oSets[0]);
   y1 = scr_gxmap_calcpoint(global.sector_y,oSets[1]);
   pathsSelected = scr_push_array(pathsSelected,scr_array(x1,y1));
}

if(is_array(global.nav_queue)){
    for(var i=0; i&lt;array_length_1d(global.nav_queue); i++){
        p = global.nav_queue[i];
        pA = scr_str_split(p,",");
        oSetString = scr_gx_get_by_key(pA[0],pA[1],"mapoffsets");
        if(!is_undefined(oSetString)){
                oSets = scr_str_split(oSetString,",");                
                x1= scr_gxmap_calcpoint(pA[0],oSets[0]);
                y1 = scr_gxmap_calcpoint(pA[1],oSets[1]);
                pathsSelected = scr_push_array(pathsSelected,scr_array(x1,y1));
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// display nav_queue
if(is_array(global.nav_queue))
{
    var qY=72;//Start drawing queue at this Y coordinate 
    for(var i=0; i&lt;array_length_1d(global.nav_queue); i++){
        var dest = global.nav_queue[i];
        if(!is_undefined(dest)){
            draw_set_font(fnt_menus);
            draw_set_color(c_lime);
            draw_set_valign(fa_top);
            draw_set_halign(fa_left);
            draw_text(32,qY + (32*i),string(dest));
        }
    }  
}

if(debug_mode){
    draw_text(gui_width-128,gui_height-32,"paths:" + string(array_length_1d(paths)));
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// buttons
var btn;
if(is_array(mButtons)){
    for(var i=0; i&lt;array_length_1d(mButtons); i++){
        btn = mButtons[i];
        scr_gui_draw_button(btn);
    }  
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw map
var pth;
if(is_array(paths)){

    for(var i=0; i&lt;array_length_1d(paths); i++){
        pth=paths[i];
        if(pth[4]){
            // paths with reciprical return paths will be white. pth[4] contains a true/false flag
            draw_set_color(c_white);
            draw_line(pth[0],pth[1],pth[2],pth[3]);
        }else{
            draw_set_color(c_gray);
            scr_draw_dotted_line(pth[0],pth[1],pth[2],pth[3],GX_MAGNITUDE);
        }
        
    }
}

pth = noone;
var x1=noone;
var yl=noone;
if(is_array(pathsSelected)){
    for(var i=0; i&lt;array_length_1d(pathsSelected); i++){
        pth=pathsSelected[i];
        if(x1==noone){
            x1=pth[0];
            y1=pth[1];
        }else{
            draw_set_color(c_orange);
            draw_line(x1,y1,pth[0],pth[1]);
            x1=pth[0];
            y1=pth[1];
        }
    }
}

if(is_array(points)){
    var pt;
    for(var i=0; i&lt;array_length_1d(points); i++){
        pt=points[i];
        if(is_array(pt)){
            draw_circle_colour( pt[0], pt[1], 4 * GX_MAGNITUDE,clr1,clr1,false);
            draw_circle_colour( pt[0], pt[1], 4 * GX_MAGNITUDE,clr2,clr2,true);
        }        
    }
}

draw_circle_colour(ctrX,ctrY,4,c_blue,c_blue,false);
draw_circle_colour( ctrX, ctrY, 4 * GX_MAGNITUDE,clr3,clr3,false);
draw_circle_colour( ctrX, ctrY, 4 * GX_MAGNITUDE,clr4,clr4,true); 
draw_triangle_colour(tx1,ty1,tx2,ty2,tx3,ty3,c_orange,c_orange,c_orange,false);




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
