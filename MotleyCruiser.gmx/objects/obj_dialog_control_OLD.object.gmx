<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.display_scale = display_get_gui_width()/view_wview[view_current];

// Get the mouse position relative to the gui not the room
global.gui_mouse_x = (mouse_x - view_xview[view_current]) * global.display_scale;
global.gui_mouse_y = (mouse_y - view_yview[view_current]) * global.display_scale;

show = false;

scr_reset_dialog();


depth=-100000000;

text_scale = 0.30; // Text has to be scaled down when using views, unless we draw to gui.

// Variables for speach bubble
popup_width = view_wview[0]*.50;           // The max width of the text inside the messagebox.
popup_padding = 3;                     // The space between the text and the edge
text = "";                              // The text to draw in the box.  If empty, the questionmark will not show.
draw_below = false;                     // Force the box to be drawn below the questionmark
font = fnt_menus;                  // The font to use when drawing the messagebox text
font_color = c_lime;                   // Color to draw the font and the border around messagebox
bak_color = c_black;                   // The color for the messagebox background
draw_message = false;
b_selected = noone; // Use to increment selected button via gampad
// End speach bubble

// Add a light
llight=noone
llight = glr_light_create(spr_glr_light_mask_point, 0, x, y, c_white, 0);
glr_light_set_static(llight, true);/// Light
glr_light_set_scaling(llight,3,3);
glr_light_set_active(llight,false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Hide box if player moves
if(instance_exists(obj_player)){
    if(obj_player.hspd!=0 || obj_player.vspd!=0){
        event_user(2);       
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// User interact
if(scr_user_input("interact")){
    event_user(0);
}

if(show &amp;&amp; scr_user_input("menu_close")){
    event_user(2);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check to see if mouse is over a button
if(show){
    var xhover = false;
    var yhover = false;
    var button_x = 0;
    var button_y = 0;
    var button_w = 0;
    var button_h = 0;
    if(staged_buttons != noone){
        for(var i = 0; i&lt;array_height_2d(staged_buttons); i++){
            if(array_length_2d(staged_buttons,i)==5){
                button_x = staged_buttons[i,0];
                button_y = staged_buttons[i,1];
                button_w = staged_buttons[i,2];
                button_h = staged_buttons[i,3];
        
                xhover = ( mouse_x == median(button_x, mouse_x, button_x + button_w) );
                yhover = ( mouse_y == median(button_y, mouse_y, button_y + button_h) );
                staged_buttons[i,4] = xhover &amp;&amp; yhover;
            }
    
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Select menu buttons via controller
if(show &amp;&amp; is_array(staged_buttons)){
    
    if( scr_user_input("menu_op_down") ){
        
        if(b_selected = noone){
            b_selected = 0;
        }else{
            b_selected = min(b_selected+1,array_height_2d(staged_buttons)-1);
        } 
         
    }else if( scr_user_input("menu_op_up") ){
        if(b_selected &gt; 0){
            b_selected = max(b_selected-1,0);
        }   
    }
    
    
    for(var i=0;i&lt;array_height_2d(staged_buttons);i++){
        if(i==b_selected){
            staged_buttons[i,4] = true;
        }else{
            staged_buttons[i,4] = false;
        }
    }
    
    if(scr_user_input("menu_op_select")){
        event_user(1);
    }
    
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// See if a button was clicked
event_user(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Close dialog
show = false;
glr_light_set_active(llight,false);
scr_reset_dialog(); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Execute code for clicked option

/***
If you add branches here, be sure to use staged_buttons = noone to clear the current buttons.
***/
if(show &amp;&amp; staged_buttons != noone){
    for(var i = 0; i&lt;array_height_2d(staged_buttons); i++){
        if(array_length_2d(staged_buttons,i)==5){
            if( staged_buttons[i,4] ){//hover = true
                //show_message("CLICKED BUTTON " + string(i) );
                var thebuttons = staged_branch[D_BRANCH_BUTTONS];
                var clicked_button = thebuttons[i];
                var next_branch = noone;
                
                if(clicked_button[D_BUTTON_SCRIPT]!=noone){
                    // Parse and run the attached script
                    scr_script_parse(clicked_button[D_BUTTON_SCRIPT]);
                }
                
                
                switch (clicked_button[D_BUTTON_ACTION]){                
                    case "step_to":
                        var link = clicked_button[D_BUTTON_LINKINDEX];
                        if(link != noone &amp;&amp; array_length_1d(staged_tree)&gt;link){
                            //Look to see if the next step is a job offer. Make sure we haven't already accepted.
                            next_branch = staged_tree[link];
                            if(next_branch[D_BRANCH_TYPE]=="job" &amp;&amp; closest_sentient.mission != noone &amp;&amp; scr_has_mission(closest_sentient.global_index)){
                                 staged_branch = scr_make_dialogue_branch("Have you finished that job yet?","exposition");
                                 scr_add_dialogue_button(staged_branch,"Nope.","step_to",0);
                                 
                            }else{
                                // Move on to the next branch normally.
                                staged_branch = staged_tree[link];
                            }

                            staged_buttons = noone; // CLEAR CURRENT BUTTONS FOR THE NEXT BRANCH
                            b_selected=noone;
                        }else{
                            staged_branch = scr_make_dialogue_branch("I have no idea how to respond to that.","exposition");
                            scr_add_dialogue_button(staged_branch,"Sorry.","step_to",0);
                            staged_buttons = noone;
                            b_selected=noone; 
                        }
                        break;
                    case "accept_mission":
                        if( !scr_has_mission(closest_sentient.mission) ){                            
                            scr_accept_mission(closest_sentient.mission);
                        }
                        
                        with(closest_sentient){
                            dialogue = scr_make_dialogue_tree();
                        }
                        show = false;
                        scr_reset_dialog();
                        
                        break;
                    case "complete_objective":
                        
                        if(clicked_button[D_BUTTON_RECORD]!=noone){
                            var complete = scr_complete_objective(clicked_button[D_BUTTON_RECORD],closest_sentient.global_index,"npc");
                            if(complete){
                                var objective = scr_find_objective(clicked_button[D_BUTTON_RECORD]);
                                var obtxt = "Success. Our business is complete.";
                                if(objective!=noone){
                                    obtxt = objective[OBJECTIVE_TEXT_END];
                                }
                                staged_branch = scr_make_dialogue_branch(obtxt,"exposition");
                                scr_add_dialogue_button(staged_branch,"Farewell.","reset",0);
                                scr_delete_button(staged_tree[0],i);
                            }else{
                                staged_branch = scr_make_dialogue_branch("You have not done what was asked of you.","exposition");
                                scr_add_dialogue_button(staged_branch,"Oops.","step_to",0);
                            }
                            staged_buttons = noone;
                            b_selected=noone;
                        }
                        
                        break;
                    case "hire_make_offer":
                        if(scr_has_mission(closest_sentient.global_index)){
                            staged_branch = scr_make_dialogue_branch("You have to finish that job for me first.","exposition");
                            scr_add_dialogue_button(staged_branch,"Oh, yeah.","step_to",0);
                        }else if( obj_ship_data.bunks &lt;= scr_get_active_crew_count()+1 ){
                            staged_branch = scr_make_dialogue_branch("You don't have an empty bunk for me. Forget it.","exposition");
                            scr_add_dialogue_button(staged_branch,"Right. Sorry!","step_to",0);
                        }else{                                     
                            staged_branch = scr_make_dialogue_branch("How much will you pay?","exposition");
                            scr_add_dialogue_button(staged_branch,string(closest_sentient.hire_price)+" a day.","hire_consider_offer",0,"scr_change_hire_price,"+string(closest_sentient.hire_price));
                            scr_add_dialogue_button(staged_branch,string(closest_sentient.hire_price+25)+" a day.","hire_consider_offer",0,"scr_change_hire_price,"+string(closest_sentient.hire_price+25));
                            scr_add_dialogue_button(staged_branch,string(closest_sentient.hire_price+50)+" a day.","hire_consider_offer",0,"scr_change_hire_price,"+string(closest_sentient.hire_price+50));
                        }
                        staged_buttons = noone;
                        b_selected=noone;
                        break;
                    case "hire_consider_offer":
                        var p = closest_sentient.hire_price;
                        var c = min(p,100);
                        if( scr_has_trait(TRAIT_GREEDY,closest_sentient.npc_data[NPC_TRAIT]) ){
                            c -= 10;
                        }
                        if( scr_has_trait(TRAIT_ARROGANT,closest_sentient.npc_data[NPC_TRAIT]) ){
                            c -= 10;
                        }
                        var r = irandom(100);
                        // The lower the price, the lower the chance
                        if(r&lt;c){
                            // WIN
                            staged_branch = scr_make_dialogue_branch("I'll do it.","exposition");
                            scr_add_dialogue_button(staged_branch,"Deal.","hire_crew",0);
                            scr_add_dialogue_button(staged_branch,"On second thought, forget it.","exit",noone,"scr_change_hire_price,"+string(closest_sentient.hire_price+25));
                        }else{
                            // LOSE
                            closest_sentient.hire_price = closest_sentient.hire_price+25;
                            staged_branch = scr_make_dialogue_branch("Not enough.","exposition");
                            scr_add_dialogue_button(staged_branch,"Maybe we can negotiate.","hire_make_offer",0);
                            scr_add_dialogue_button(staged_branch,"That's all I can offer.","step_to",0);                       
                        }
                        staged_buttons = noone;
                        b_selected=noone;
                        break;
                        
                    case "hire_crew":
                        // Grant some equipment to the npc                      
                        var rnd_weapon = scr_grant_random_weapon();
                        if(rnd_weapon==noone){
                            rnd_weapon = 51;
                        }
                        var equip_array = noone;
                        equip_array[EQUIP_WEAPON1]=rnd_weapon;
                                                
                        if(array_length_1d(closest_sentient.npc_data)&lt;NPC_EQUIPMENT){
                            closest_sentient.npc_data[NPC_EQUIPMENT] = noone;
                        }
                        closest_sentient.npc_data[NPC_EQUIPMENT]=equip_array;
                        
                        global.crew = scr_push_array(global.crew,closest_sentient.npc_data);
                        with(closest_sentient){
                            instance_change(obj_crew,true);
                            scr_npc_map_to_object();
                        }

                        closest_sentient.crew_index = array_length_1d(global.crew)-1;
                        
                        show = false;
                        scr_reset_dialog();
                        
                        break;
                        
                    case "repair_ships":
                        var repair_cost = scr_repair_all_ship_cost();
                        staged_branch = scr_make_dialogue_branch("It will cost you "+string(repair_cost)+"c.","exposition");
                        if(repair_cost&lt;=global.credits || repair_cost==0){
                            scr_add_dialogue_button(staged_branch,"Deal.","exit",noone,"scr_repair_all_ships");
                        }
                        scr_add_dialogue_button(staged_branch,"I can't afford that.","exit");
                        staged_buttons = noone;
                        b_selected=noone;
                        break;
                                                
                    case "reset":
                        if(closest_sentient==noone) exit;
                        with(closest_sentient){
                            dialogue = scr_make_dialogue_tree();
                        }
                        staged_tree = closest_sentient.dialogue;
                        staged_branch = staged_tree[0];
                        staged_buttons = noone;
                        b_selected=noone;
                        break;      
                        
                    case "intro":
                        staged_branch = staged_tree[0];
                        staged_buttons = noone;
                        b_selected=noone;
                        break;
                    case "exit":
                        show = false;
                        scr_reset_dialog();
                        break;
                    default:
                        staged_branch = scr_make_dialogue_branch("I don't feel like talking now.","exposition");
                        scr_add_dialogue_button(staged_branch,"Sorry.","exit",noone);
                        staged_buttons = noone;
                        b_selected=noone; 
                
                }
                


            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Open dialog or trade window.
if(show) exit;

scr_reset_dialog();
var this_sentient = noone;
var closest_range = 0;
var this_range = 0;


for(var i = 0; i &lt; instance_number(obj_sentient); i++) {
    this_sentient = instance_find(obj_sentient,i);
    this_range = point_distance(obj_player.x,obj_player.y,this_sentient.x,this_sentient.y);
    if(this_range&lt;50){
        if(closest_sentient==noone){
            closest_sentient = this_sentient;
            closest_range = this_range;
        }else if(this_range&lt;closest_range){
            closest_sentient = this_sentient;
            closest_range = this_range;
        }
    }
}

if(closest_sentient != noone &amp;&amp; closest_sentient.name != noone){

    if(closest_sentient.is_trader){
        
        if(instance_exists(obj_trade)){

            with(obj_trade){
                show = true;
                event_user(0);
            }           
           
        }
    
    }else{
        
        with(closest_sentient){
            dialogue = scr_make_dialogue_tree();
        }
        staged_tree = closest_sentient.dialogue;
        staged_branch = staged_tree[0];
        show=true;
        
               
    }
          

    
}


if(show){

    glr_light_set_active(llight,true);
    glr_light_set_position(llight,closest_sentient.x,closest_sentient.y);


}else{

    glr_light_set_active(llight,show);

}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(show &amp;&amp; staged_branch!=noone &amp;&amp; closest_sentient.name != noone){
    
    draw_set_font(font);
    draw_set_color(font_color);
    var font_size = font_get_size(font);
    
    var bub = scr_draw_messagebox_plus(closest_sentient.name + ": " + staged_branch[D_BRANCH_TEXT], popup_width, popup_padding, closest_sentient, bak_color, draw_below, staged_branch[D_BRANCH_BUTTONS]);
    if(bub != noone){
        var thebuttons = staged_branch[D_BRANCH_BUTTONS];
        var thisbutton = noone;
        var button_x = bub[0];
        var button_y = bub[1];
        var button_w = 0;
        var button_h = 0;
        for(var i = 0; i &lt; array_length_1d(thebuttons); i++){
            thisbutton = thebuttons[i];
            
            button_w = round( string_width( thisbutton[D_BUTTON_TEXT] ) * text_scale );
            button_h = round( string_height( thisbutton[D_BUTTON_TEXT] ) * text_scale );           
            // Store the coordinates and state of the button. x, y, width, height, hover
            if( array_height_2d( staged_buttons ) &lt; array_length_1d(thebuttons) ){ // Be sure you only do this once for each button
                staged_buttons[i,0]=button_x;
                staged_buttons[i,1]=button_y;
                staged_buttons[i,2]=button_w;
                staged_buttons[i,3]=button_h;
                staged_buttons[i,4]=false;
            }
            scr_draw_button(thisbutton[D_BUTTON_TEXT], button_x, button_y, staged_buttons[i,4]);
            button_y += button_h + 1;
            
        }  
    }

    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="84">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Open dialog box if player in range
exit;//disable for now

show = !show;
scr_reset_dialog();
var this_sentient = noone;
var closest_range = 0;
var this_range = 0;


if(show){

    for(var i = 0; i &lt; instance_number(obj_sentient); i++) {
        this_sentient = instance_find(obj_sentient,i);
        this_range = point_distance(obj_player.x,obj_player.y,this_sentient.x,this_sentient.y);
        if(this_range&lt;50){
            if(closest_sentient==noone){
                closest_sentient = this_sentient;
                closest_range = this_range;
            }else if(this_range&lt;closest_range){
                closest_sentient = this_sentient;
                closest_range = this_range;
            }
        }
    }
    
    if(closest_sentient != noone &amp;&amp; closest_sentient.name != noone){
    
        if(closest_sentient.is_trader){
            if(instance_exists(obj_trade)){

                with(obj_trade){
                    show = true;
                    event_user(0);
                }           
               
            }
        
        }else{
            with(closest_sentient){
                dialogue = scr_make_dialogue_tree();
            }
            staged_tree = closest_sentient.dialogue;
            staged_branch = staged_tree[0];       
        }
              

        
        glr_light_set_active(llight,true);
        glr_light_set_position(llight,closest_sentient.x,closest_sentient.y);
        
    }


}
glr_light_set_active(llight,show);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
